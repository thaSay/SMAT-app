<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Programação em Blocos para Robô Stop Motion</title>
    <!-- Alterado para CDN unpkg e versão específica do Blockly -->
    <script src="https://unpkg.com/blockly@10.4.0/blockly_compressed.js"></script>
    <script src="https://unpkg.com/blockly@10.4.0/javascript_compressed.js"></script>
    <script src="https://unpkg.com/blockly@10.4.0/msg/pt.js"></script>
    <!-- Scripts locais para blocos e geradores -->
    <script src="{{ url_for('static', filename='blocks.js') }}"></script>
    <script src="{{ url_for('static', filename='generator.js') }}"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Slackey&display=swap"
      rel="stylesheet"
    />

    <style>
      .slackey-regular {
        font-family: "Slackey", sans-serif;
        font-weight: 400;
        font-style: normal;
        font-size: 30px;
      }
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        height: 100vh;
        flex-direction: column;
      }

      #header-container {
        padding: 10px;
        background-color: #e0e0e0;
        display: flex;
        justify-content: center;
      }

      #main-container {
        display: flex;
        flex: 1;
        overflow: hidden;
      }

      #blockly-container {
        flex: 2;
        height: 100%;
        position: relative; /* Necessário para o Blockly se dimensionar corretamente */
        .blocklyToolboxDiv {
          background-color: #f0f0f0;
        }
      }
      #output-column {
        flex: 1;
        background-color: #f0f0f0;
        padding: 10px;
        display: flex;
        flex-direction: column;
        overflow-y: auto; /* Barra de rolagem se o conteúdo exceder */
      }
      #code-output-container,
      #result-container,
      #program-output-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        margin-bottom: 10px;
        min-height: 150px; /* Altura mínima para as caixas de saída */
      }
      #code-output,
      #result-output,
      #program-output {
        flex: 1;
        background-color: white;
        border: 1px solid #ddd;
        padding: 10px;
        font-family: monospace;
        overflow: auto;
        white-space: pre-wrap; /* Para quebrar linha no JSON */
        word-break: break-all; /* Para quebrar palavras longas */
      }

      #button-container {
        display: flex;
        justify-content: space-between;
        padding: 20px;
        background-color: #e0e0e0;
      }
      #upload-file {
        padding: 8px 16px;
        background-color: #4a6ea9;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }
      button {
        padding: 8px 16px;
        background-color: #4a6ea9;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }
      button:hover {
        background-color: #3a5ea9;
      }
      #execute-btn {
        background-color: #4caf50;
      }
      #execute-btn:hover {
        background-color: #3a9140;
      }
      #clear-btn {
        background-color: #f44336;
      }
      #clear-btn:hover {
        background-color: #d32f2f;
      }
      h3 {
        margin-top: 0;
        margin-bottom: 5px;
      }

      /* Help button styles */
      #help-btn {
        background-color: #2196f3;
        border-radius: 50%;
        font-weight: bold;
        width: 40px;
        height: 40px;
      }

      /* Modal styles */
      .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0, 0, 0, 0.4);
      }

      .video-player {
        width: 100%;
        height: 100%;
        object-fit: cover; /* ou 'contain', dependendo do que você quiser */
        display: block;
      }

      .modal-content {
        background-color: #fefefe;
        margin: 15% auto;
        padding: 20px;
        border: 1px solid #888;
        width: 70%;
        max-width: 800px;
      }

      .close {
        color: #aaa;
        float: right;
        font-size: 28px;
        font-weight: bold;
        cursor: pointer;
      }

      .close:hover {
        color: black;
      }

      /* Estilos para o painel de controle */
      #control-panel {
        flex: 1;
        min-width: 300px;
        max-width: 500px;
        background-color: #f0f0f0;
        padding: 15px;
        border-left: 1px solid #ddd;
        display: flex;
        flex-direction: column;
        overflow: auto;
      }

      .panel-title {
        font-family: Arial, sans-serif;
        font-size: 20px;
        font-weight: bold;
        text-align: center;
        margin-top: 0;
        margin-bottom: 15px;
      }

      .panel-section {
        margin-bottom: 15px;
      }

      .text-display {
        background-color: white;
        border: 1px solid #ddd;
        padding: 10px;
        font-family: monospace;
        height: 100px;
        overflow-y: auto;
        white-space: pre-wrap;
        word-break: break-all;
      }

      #video-result-display {
        height: 10px;
        color: #555;
      }

      .image-placeholder {
        background-color: #e0e0e0;
        border: 1px solid #ccc;
        padding: 20px;
        text-align: center;
        display: flex;
        align-items: center;
        justify-content: center;
        margin-top: 5px;
      }

      .button-container {
        display: flex;
        flex-direction: column;
        gap: 10px;
      }

      .action-button {
        padding: 8px;
        font-size: 14px;
        cursor: pointer;
        background-color: #4a6ea9;
        color: white;
        border: none;
        border-radius: 4px;
      }

      .action-button:hover {
        background-color: #3a5ea9;
      }

      .danger-button {
        background-color: #f44336;
      }

      .danger-button:hover {
        background-color: #d32f2f;
      }

      /* Estilos para a barra de progresso */
      .progress-bar-container {
        width: 100%;
        background-color: #e0e0e0;
        height: 20px;
        border-radius: 10px;
        margin-top: 5px;
        margin-bottom: 5px;
      }

      .progress-bar {
        width: 0%;
        height: 20px;
        background-color: #4caf50;
        border-radius: 10px;
        transition: width 0.3s;
      }

      #export-progress-text {
        text-align: center;
        font-size: 14px;
      }
    </style>
  </head>
  <body>
    <div id="header-container">
      <div class="slackey-regular">SMAT</div>
      <div></div>
    </div>

    <div id="main-container">
      <div id="blockly-container"></div>
      <!-- Control panel will be moved here -->
      <div id="control-panel">
        <h2 class="panel-title">Control Panel</h2>

        <div class="panel-section">
          <h3>JSON Generated by Blocks:</h3>
          <div
            id="json-data-display"
            class="text-display"
            contenteditable="true"
          ></div>
        </div>

        <div class="panel-section">
          <h3>Status:</h3>
          <div id="video-result-display" class="text-display"></div>
        </div>

        <div class="panel-section">
          <h3>Robot Video:</h3>
          <div id="robot-image-placeholder" class="image-placeholder">
            <!-- <video class="video-player" width="640" controls>
              <source
                src="{{url_for('static', filename='videos/display_video.mp4')}}"
                type="video/mp4"
              />

              Your browser does not support the video tag.
            </video> -->
          </div>
        </div>

        <div class="panel-section button-container">
          <button id="export-video-button" class="action-button">
            Export Video MP4
          </button>
          <button id="merge-button" class="action-button">
            Merge with the previous Video
          </button>
          <button id="delete-button" class="action-button danger-button">
            Delete Last Video
          </button>
        </div>

        <!-- Progress bar for video export -->
        <div id="export-progress-container" style="display: none">
          <h3>Export Progress:</h3>
          <div class="progress-bar-container">
            <div id="export-progress-bar" class="progress-bar"></div>
          </div>
          <div id="export-progress-text">0%</div>
        </div>
      </div>
      <!-- Hidden output for internal logic -->
      <div id="code-output-container" style="display: none">
        <h3>JSON Gerado:</h3>
        <pre id="code-output"></pre>
      </div>
    </div>

    <xml id="toolbox" style="display: none">
      <category name="Movements" colour="120">
        <block type="robo_pose"></block>
        <block type="movimento_sequence"></block>
      </category>
    </xml>

    <script>
      window.addEventListener("load", function () {
        // Inicializar o Blockly
        var blocklyDiv = document.getElementById("blockly-container");
        var workspace = Blockly.inject(blocklyDiv, {
          toolbox: document.getElementById("toolbox"),
          grid: {
            spacing: 20,
            length: 3,
            colour: "#ccc",
            snap: true,
          },
          zoom: {
            controls: true,
            wheel: true,
            startScale: 1.0,
            maxScale: 3,
            minScale: 0.3,
            scaleSpeed: 1.2,
          },
          trashcan: true,
        });

        // Função para redimensionar o Blockly (simplificada)
        setTimeout(() => {
          Blockly.svgResize(workspace);
        }, 0);

        // Atualizar o JSON gerado quando o workspace mudar
        function updateGeneratedJson() {
          var code = Blockly.JavaScript.workspaceToCode(workspace);
          console.log("Raw output from workspaceToCode:", code);

          if (code && code.trim() !== "") {
            let jsonObjects = code.trim();
            if (jsonObjects.endsWith(";")) {
              jsonObjects = jsonObjects.slice(0, -1).trim();
            }
            if (jsonObjects === "") {
              document.getElementById("code-output").textContent = "[]";
              return;
            }
            try {
              JSON.parse(jsonObjects);
              document.getElementById("code-output").textContent = jsonObjects;
            } catch (e) {
              const individualJsons = jsonObjects.replace(/}\s*{/g, "},\n{");
              const potentialArray = "[" + individualJsons + "]";
              try {
                JSON.parse(potentialArray);
                document.getElementById("code-output").textContent =
                  potentialArray;
              } catch (eArrayParse) {
                document.getElementById("code-output").textContent =
                  jsonObjects;
                console.error(
                  "Falha ao formatar o código gerado como um array JSON. Código original:",
                  jsonObjects,
                  "Erro de parse do array:",
                  eArrayParse
                );
              }
            }
          } else {
            document.getElementById("code-output").textContent = "[]";
          }
        }
        workspace.addChangeListener(updateGeneratedJson); // Enviar para o Robô (Executar) - Modificado para usar endpoints Flask
        function executeCode() {
          var jsonOutput = document.getElementById("code-output").textContent;
          console.log(
            "Botão Executar pressionado. JSON para enviar:",
            jsonOutput
          );

          let dataToSend;
          try {
            dataToSend = JSON.parse(jsonOutput);
          } catch (error) {
            alert(
              "Erro de parsing no JSON gerado: " +
                error +
                '\nVerifique a área "JSON Gerado" (oculta).'
            );
            console.error("Erro de parsing no JSON:", error);
            return;
          }

          console.log("Dados que serão enviados:", dataToSend);

          // Enviar dados via fetch para endpoint Flask
          fetch("/execute", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
            },
            body: JSON.stringify(dataToSend),
          })
            .then((response) => {
              console.log("Response do servidor recebida:", response);
              return response.json();
            })
            .then((data) => {
              console.log("Resposta completa do servidor:", data);
              if (data.success) {
                console.log(
                  "Dados enviados com sucesso para o painel de controle."
                );
                console.log(
                  "Dados processados retornados:",
                  data.processed_output
                );
                console.log(
                  "Dados originais recebidos pelo servidor:",
                  data.received_data
                );
              } else {
                console.error("Falha ao enviar dados:", data.error);
                alert(
                  "Falha ao enviar dados: " +
                    (data.error || "Erro desconhecido")
                );
              }
            })
            .catch((error) => {
              console.error("Erro ao comunicar com o servidor:", error);
              alert("Erro ao comunicar com o servidor: " + error);
            });
        } // Adicionar listeners para os botões
        document
          .getElementById("execute-btn")
          .addEventListener("click", executeCode);

        // Limpar o workspace
        function clearWorkspace() {
          if (confirm("Tem certeza que deseja limpar todos os blocos?")) {
            workspace.clear();
            document.getElementById("code-output").textContent = "[]"; // Limpa JSON para '[]'
          }
        }

        document
          .getElementById("clear-btn")
          .addEventListener("click", clearWorkspace);

        // Salvar blocos
        document
          .getElementById("save-btn")
          .addEventListener("click", function () {
            console.log(
              "Botão 'Salvar Blocos' clicado. Verificando Blockly.Xml..."
            );
            console.log("typeof Blockly:", typeof Blockly);
            if (typeof Blockly !== "undefined") {
              console.log("typeof Blockly.Xml:", typeof Blockly.Xml);
              if (typeof Blockly.Xml !== "undefined") {
                console.log(
                  "typeof Blockly.Xml.workspaceToDom:",
                  typeof Blockly.Xml.workspaceToDom
                );
              }
              console.log("typeof Blockly.utils:", typeof Blockly.utils);
              if (typeof Blockly.utils !== "undefined") {
                console.log(
                  "typeof Blockly.utils.xml:",
                  typeof Blockly.utils.xml
                );
                if (typeof Blockly.utils.xml !== "undefined") {
                  console.log(
                    "typeof Blockly.utils.xml.domToText:",
                    typeof Blockly.utils.xml.domToText
                  );
                }
              }
            }

            if (
              typeof Blockly === "undefined" ||
              typeof Blockly.Xml === "undefined" ||
              typeof Blockly.utils === "undefined" ||
              typeof Blockly.utils.xml === "undefined" ||
              typeof Blockly.Xml.workspaceToDom !== "function" ||
              typeof Blockly.utils.xml.domToText !== "function"
            ) {
              alert(
                "Erro: Funções essenciais do Blockly para salvar XML não estão disponíveis."
              );
              console.error(
                "Erro: Funções essenciais do Blockly para salvar XML não estão disponíveis. Blockly:",
                Blockly,
                "Blockly.Xml:",
                Blockly && Blockly.Xml,
                "Blockly.utils.xml:",
                Blockly && Blockly.utils && Blockly.utils.xml
              );
              return;
            }
            try {
              var xml = Blockly.Xml.workspaceToDom(workspace);
              var xmlText = Blockly.utils.xml.domToText(xml);

              fetch("/save", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ blocks: xmlText }),
              })
                .then((response) => response.json())
                .then((data) => {
                  if (data.success) {
                    alert("Blocos salvos com sucesso!");
                  } else {
                    alert(
                      "Erro ao salvar blocos: " +
                        (data.error || "Erro desconhecido")
                    );
                  }
                })
                .catch((error) => {
                  alert("Erro na comunicação ao salvar: " + error);
                });
            } catch (e) {
              alert("Erro ao serializar os blocos: " + e);
              console.error("Erro ao serializar blocos (save-btn):", e);
            }
          });

        // Carregar blocos
        document
          .getElementById("load-btn")
          .addEventListener("click", function () {
            console.log(
              "Botão 'Carregar Blocos' clicado. Verificando Blockly.Xml..."
            );
            console.log("typeof Blockly:", typeof Blockly);
            if (typeof Blockly !== "undefined") {
              console.log("typeof Blockly.Xml:", typeof Blockly.Xml);
              if (typeof Blockly.Xml !== "undefined") {
                console.log(
                  "typeof Blockly.Xml.domToWorkspace:",
                  typeof Blockly.Xml.domToWorkspace
                );
              }
              console.log("typeof Blockly.utils:", typeof Blockly.utils);
              if (typeof Blockly.utils !== "undefined") {
                console.log(
                  "typeof Blockly.utils.xml:",
                  typeof Blockly.utils.xml
                );
                if (typeof Blockly.utils.xml !== "undefined") {
                  console.log(
                    "typeof Blockly.utils.xml.textToDom:",
                    typeof Blockly.utils.xml.textToDom
                  );
                }
              }
            }

            fetch("/load")
              .then((response) => response.json())
              .then((data) => {
                if (data.success && data.blocks) {
                  if (
                    typeof Blockly === "undefined" ||
                    typeof Blockly.Xml === "undefined" ||
                    typeof Blockly.utils === "undefined" ||
                    typeof Blockly.utils.xml === "undefined" ||
                    typeof Blockly.utils.xml.textToDom !== "function" ||
                    typeof Blockly.Xml.domToWorkspace !== "function"
                  ) {
                    let errorMsg =
                      "Erro: Funções essenciais do Blockly para carregar XML não estão disponíveis.";
                    console.error(
                      errorMsg,
                      "Blockly:",
                      Blockly,
                      "Blockly.Xml:",
                      Blockly && Blockly.Xml,
                      "Blockly.utils.xml:",
                      Blockly && Blockly.utils && Blockly.utils.xml
                    );
                    alert(errorMsg);
                    return;
                  }
                  try {
                    workspace.clear();
                    var xml = Blockly.utils.xml.textToDom(data.blocks);
                    Blockly.Xml.domToWorkspace(xml, workspace);
                    alert("Blocos carregados com sucesso!");
                    updateGeneratedJson();
                  } catch (e) {
                    alert("Erro ao carregar blocos para o workspace: " + e);
                    console.error(
                      "Erro detalhado ao carregar blocos para o workspace (load-btn):",
                      e
                    );
                    workspace.clear();
                  }
                } else {
                  alert(
                    data.error ||
                      "Nenhum bloco salvo encontrado ou falha ao carregar."
                  );
                }
              })
              .catch((error) => {
                alert("Erro na comunicação ao carregar: " + error);
                console.error("Erro de fetch ao carregar blocos:", error);
              });
          });

        // Adicionar blocos padrão ao carregar
        var defaultBlocksXml = `
      <xml xmlns="https://developers.google.com/blockly/xml">
        <block type="movimento_sequence" id="default_movimento" x="50" y="50">
          <field name="FPS">10</field>
          <field name="Duracao">1000</field>
          <value name="Inicio">
            <block type="robo_pose" id="default_inicio">
              <field name="OwnAxis">0</field>
              <field name="X">0</field>
              <field name="Y">0</field>
              <field name="BDireito">0</field>
              <field name="BEsquerdo">0</field>
              <field name="PDireito">0</field>
              <field name="PEsquerdo">0</field>
            </block>
          </value>
          <value name="Fim">
            <block type="robo_pose" id="default_fim">
              <field name="OwnAxis">0</field>
              <field name="X">0</field>
              <field name="Y">50</field>
              <field name="BDireito">0</field>
              <field name="BEsquerdo">0</field>
              <field name="PDireito">0</field>
              <field name="PEsquerdo">0</field>
            </block>
          </value>
        </block>
      </xml>
      `;
        console.log(
          "Verificando Blockly e Blockly.Xml antes de carregar blocos padrão (dentro do window.onload):"
        );
        console.log("Blockly:", typeof Blockly);
        if (typeof Blockly !== "undefined") {
          console.log("Blockly.Xml:", typeof Blockly.Xml);
          if (typeof Blockly.Xml !== "undefined") {
            console.log(
              "Blockly.Xml.domToWorkspace:",
              typeof Blockly.Xml.domToWorkspace
            );
          }
          console.log("Blockly.utils:", typeof Blockly.utils);
          if (typeof Blockly.utils !== "undefined") {
            console.log("Blockly.utils.xml:", typeof Blockly.utils.xml);
            if (typeof Blockly.utils.xml !== "undefined") {
              console.log(
                "Blockly.utils.xml.textToDom:",
                typeof Blockly.utils.xml.textToDom
              );
            }
          }
        }

        try {
          if (
            typeof Blockly !== "undefined" &&
            typeof Blockly.Xml !== "undefined" &&
            typeof Blockly.utils !== "undefined" &&
            typeof Blockly.utils.xml !== "undefined" &&
            typeof Blockly.utils.xml.textToDom === "function" &&
            typeof Blockly.Xml.domToWorkspace === "function"
          ) {
            var xml = Blockly.utils.xml.textToDom(defaultBlocksXml);
            Blockly.Xml.domToWorkspace(xml, workspace);
          } else {
            console.error(
              "Funções XML do Blockly (textToDom ou domToWorkspace) não estão disponíveis. Não foi possível carregar blocos padrão."
            );
            alert(
              "Alerta: Não foi possível carregar os blocos padrão iniciais devido à falta de funções XML do Blockly."
            );
          }
        } catch (e) {
          console.error(
            "Erro ao carregar blocos padrão (dentro do try-catch principal):",
            e
          );
          alert(
            "Alerta: Erro ao tentar carregar os blocos padrão iniciais: " +
              e.message
          );
        }

        updateGeneratedJson(); // Atualiza o JSON ao carregar a página e após adicionar blocos padrão
      }); // Fim do window.addEventListener('load', ...)
      // Help modal functionality
      document.addEventListener("DOMContentLoaded", function () {
        var modal = document.getElementById("helpModal");
        var btn = document.getElementById("help-btn");
        var span = document.getElementsByClassName("close")[0];

        btn.onclick = function () {
          modal.style.display = "block";
        };

        span.onclick = function () {
          modal.style.display = "none";
        };

        window.onclick = function (event) {
          if (event.target == modal) {
            modal.style.display = "none";
          }
        };
      });

      // Control panel functionality
      document.addEventListener("DOMContentLoaded", function () {
        // Variables
        let lastUpdate = new Date();
        let pollingInterval = 5000; // 5 seconds

        // Elements
        const jsonDataDisplay = document.getElementById("json-data-display");
        const videoResultDisplay = document.getElementById(
          "video-result-display"
        );
        const robotImagePlaceholder = document.getElementById(
          "robot-image-placeholder"
        );
        const mergeButton = document.getElementById("merge-button");
        const exportVideoButton = document.getElementById(
          "export-video-button"
        );
        const deleteButton = document.getElementById("delete-button");
        const exportProgressContainer = document.getElementById(
          "export-progress-container"
        );
        const exportProgressBar = document.getElementById(
          "export-progress-bar"
        );
        const exportProgressText = document.getElementById(
          "export-progress-text"
        );

        // Initialize data display
        jsonDataDisplay.textContent = "No data received.";

        // Update data from server
        function updateData() {
          fetch("/api/get_control_data")
            .then((response) => response.json())
            .then((data) => {
              if (
                data &&
                data.timestamp &&
                new Date(data.timestamp) > lastUpdate
              ) {
                lastUpdate = new Date(data.timestamp);
                if (data.json_data) {
                  jsonDataDisplay.textContent = JSON.stringify(
                    data.json_data,
                    null,
                    2
                  );
                }
                if (data.video_result) {
                  videoResultDisplay.textContent = data.video_result;
                }
                if (data.robot_image) {
                  robotImagePlaceholder.textContent = data.robot_image;
                }
              }
            })
            .catch((error) =>
              console.error("Error fetching control data:", error)
            );
        }

        // Start polling for updates
        setInterval(updateData, pollingInterval);

        // Capture button click
        mergeButton.addEventListener("click", function () {
          fetch("/api/concat_videos", { method: "POST" })
            .then((response) => response.json())
            .then((data) => {
              if (data.success) {
                const placeholder = document.getElementById(
                  "robot-image-placeholder"
                );

                const uniqueUrl =
                  "{{url_for('static', filename='videos/display_video.mp4')}}" +
                  "?t=" +
                  new Date().getTime();

                placeholder.innerHTML = `
                  <video class="video-player" width="640" controls>
                    <source
                      src="${uniqueUrl}"
                      type="video/mp4"
                    />
                    Your browser does not support the video tag.
                  </video>
                  `;
              } else {
                alert(
                  "Error capturing photo: " + (data.error || "Unknown error")
                );
              }
            })
            .catch((error) => {
              console.error("Error capturing photo:", error);
              alert("Error capturing photo: " + error);
            });
        });

        // Export video button click
        exportVideoButton.addEventListener("click", function () {
          // Show progress container
          exportProgressContainer.style.display = "block";
          exportProgressBar.style.width = "0%";
          exportProgressText.textContent = "0%";

          var jsonInfo = document.getElementById("code-output").textContent;
          dataToSend = JSON.parse(jsonInfo);

          // Start export process
          fetch("/api/export_video", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
            body: JSON.stringify(dataToSend),
          })
            .then((response) => {
              if (!response.ok) {
                throw new Error(`HTTP error ${response.status}`);
              }
              return response.json();
            })
            .then((data) => {
              if (!data.success) {
                throw new Error(data.error || "Unknown error");
              }

              // Start progress polling
              const pollProgress = setInterval(() => {
                fetch("/api/export_progress")
                  .then((response) => {
                    if (!response.ok) {
                      throw new Error(`HTTP error ${response.status}`);
                    }
                    return response.json();
                  })
                  .then((progressData) => {
                    if (progressData.complete) {
                      clearInterval(pollProgress);
                      exportProgressBar.style.width = "100%";
                      exportProgressText.textContent = "100%";

                      setTimeout(() => {
                        exportProgressContainer.style.display = "none";
                        alert("Video exported successfully!");
                        videoResultDisplay.textContent =
                          "Video exported successfully!";
                        const placeholder = document.getElementById(
                          "robot-image-placeholder"
                        );
                        const uniqueUrl =
                          "{{url_for('static', filename='videos/display_video.mp4')}}" +
                          "?t=" +
                          new Date().getTime();

                        placeholder.innerHTML = `
                        <video class="video-player" width="640" controls>
                          <source
                            src="${uniqueUrl}"
                            type="video/mp4"
                          />
                          Your browser does not support the video tag.
                        </video>
                          `;
                      }, 1000);
                    } else if (progressData.error) {
                      clearInterval(pollProgress);
                      exportProgressContainer.style.display = "none";
                      alert("Error exporting video: " + progressData.error);
                    } else {
                      exportProgressBar.style.width =
                        progressData.progress + "%";
                      exportProgressText.textContent =
                        progressData.progress + "%";
                    }
                  })
                  .catch((error) => {
                    clearInterval(pollProgress);
                    console.error("Error checking export progress:", error);
                  });
              }, 500);
            })
            .catch((error) => {
              exportProgressContainer.style.display = "none";
              console.error("Error exporting video:", error);
              alert("Error exporting video: " + error);
            });
        });

        // Close button click - only if running in desktop mode
        deleteButton.addEventListener("click", function () {
          if (
            confirm("Are you sure you want to delete the last recording video?")
          ) {
            fetch("/api/delete_video", { method: "POST" })
              .then((response) => response.json())
              .then((data) => {
                if (!data.success) {
                  alert(data.error || "Failed to close application");
                } else {
                  const placeholder = document.getElementById(
                    "robot-image-placeholder"
                  );
                  placeholder.innerHTML = ``;
                }
              })
              .catch((error) => {
                console.error("Error closing application:", error);
              });
          }
        });

        document
          .getElementById("upload-file")
          .addEventListener("click", openDialog);

        document
          .getElementById("fileid")
          .addEventListener("change", function () {
            const file = this.files[0];
            if (file) {
              const formData = new FormData();
              formData.append("arquivo", file);

              // Enviar via fetch
              fetch("/api/remove_background", {
                method: "POST",
                body: formData,
              })
                .then((response) => response.text())
                .then((result) => {
                  console.log("Sucesso:", result);
                  alert("Arquivo enviado com sucesso!");

                  const placeholder = document.getElementById(
                    "robot-image-placeholder"
                  );
                  const uniqueUrl =
                    "{{url_for('static', filename='videos/display_video.mp4')}}" +
                    "?t=" +
                    new Date().getTime();

                  placeholder.innerHTML = `
                    <video class="video-player" width="640" controls>
                      <source
                        src="${uniqueUrl}"
                        type="video/mp4"
                      />
                      Your browser does not support the video tag.
                    </video>
                          `;
                })
                .catch((error) => {
                  console.error("Erro:", error);
                  alert("Erro no envio do arquivo.");
                });
            }
          });

        function openDialog() {
          document.getElementById("fileid").click();
        }
      });
    </script>
    <div id="button-container">
      <div>
        <button id="save-btn">Save blocks</button>
        <button id="load-btn">Load Blocks</button>
        <button id="clear-btn">Clean Blocks</button>
      </div>
      <div>
        <button id="execute-btn">Send to the robot</button>

        <input id="fileid" type="file" hidden />
        <input id="upload-file" type="button" value="Add Background" />

        <button>Add Soundtrack</button>
        <button id="help-btn" title="Help">?</button>
      </div>
    </div>
    <div id="helpModal" class="modal">
      <div class="modal-content">
        <span class="close">&times;</span>
        <h2>SMAT Application Help</h2>
        <h3>Getting Started</h3>
        <p>
          Welcome to the Stop Motion Animation Table application. This tool
          allows you to create robot animations using block programming.
        </p>

        <h3>Basic Usage</h3>
        <ol>
          <li>
            <strong>Building Blocks:</strong> Drag blocks from the toolbox (left
            panel) to create your animation sequence.
          </li>
          <li>
            <strong>Robot Pose:</strong> Use the "Robot" block to define
            positions for different parts of the robot.
          </li>
          <li>
            <strong>Movement:</strong> Use the "Movement" block to create
            animations between two poses.
          </li>
          <li>
            <strong>Execution:</strong> Click "Send to the robot" to execute
            your animation.
          </li>
        </ol>

        <h3>Block Types</h3>
        <ul>
          <li>
            <strong>Robot:</strong> Defines the robot's position (X, Y) and
            joint angles.
          </li>
          <li>
            <strong>Movement:</strong> Creates a sequence between initial and
            final positions with specified duration and FPS.
          </li>
        </ul>

        <p>
          For more detailed help and tutorials, please visit
          <a
            href="https://www.notion.so/Stop-Motion-Animation-Table-1d7efc552d9e808b9c6ceef3e1ebab2a"
            target="_blank"
            >our blog</a
          >.
        </p>
      </div>
    </div>
  </body>
</html>
