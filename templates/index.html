<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Programação em Blocos para Robô Stop Motion</title>
    <!-- Alterado para CDN unpkg e versão específica do Blockly -->
    <script src="https://unpkg.com/blockly@10.4.0/blockly_compressed.js"></script>
    <script src="https://unpkg.com/blockly@10.4.0/javascript_compressed.js"></script>
    <script src="https://unpkg.com/blockly@10.4.0/msg/pt.js"></script>
    <!-- Scripts locais para blocos e geradores -->
    <script src="{{ url_for('static', filename='blocks.js') }}"></script>
    <script src="{{ url_for('static', filename='generator.js') }}"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Slackey&display=swap"
      rel="stylesheet"
    />

    <style>
      .slackey-regular {
        font-family: "Slackey", sans-serif;
        font-weight: 400;
        font-style: normal;
        font-size: 30px;
      }
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        display: flex;
        height: 100vh;
        flex-direction: column;
      }
      #header {
        background-color: #4a6ea9;
        color: white;
        padding: 10px;
        text-align: center;
      }
      #main-container {
        display: flex;
        flex: 1;
        overflow: hidden; /* Para evitar barras de rolagem desnecessárias no corpo */
      }
      #blockly-container {
        flex: 2;
        height: 100%;
        position: relative; /* Necessário para o Blockly se dimensionar corretamente */
        .blocklyToolboxDiv {
          background-color: #f0f0f0;
        }
      }
      #output-column {
        flex: 1;
        background-color: #f0f0f0;
        padding: 10px;
        display: flex;
        flex-direction: column;
        overflow-y: auto; /* Barra de rolagem se o conteúdo exceder */
      }
      #code-output-container,
      #result-container,
      #program-output-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        margin-bottom: 10px;
        min-height: 150px; /* Altura mínima para as caixas de saída */
      }
      #code-output,
      #result-output,
      #program-output {
        flex: 1;
        background-color: white;
        border: 1px solid #ddd;
        padding: 10px;
        font-family: monospace;
        overflow: auto;
        white-space: pre-wrap; /* Para quebrar linha no JSON */
        word-break: break-all; /* Para quebrar palavras longas */
      }
      #header-container {
        padding: 10px;
        background-color: #e0e0e0;
        display: flex;
        justify-content: center;
      }

      #button-container {
        display: flex;
        justify-content: space-between;
        padding: 20px;
        background-color: #e0e0e0;
      }
      button {
        padding: 8px 16px;
        background-color: #4a6ea9;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
      }
      button:hover {
        background-color: #3a5ea9;
      }
      #execute-btn {
        background-color: #4caf50;
      }
      #execute-btn:hover {
        background-color: #3a9140;
      }
      #clear-btn {
        background-color: #f44336;
      }
      #clear-btn:hover {
        background-color: #d32f2f;
      }
      h3 {
        margin-top: 0;
        margin-bottom: 5px;
      }
    </style>
  </head>
  <body>
    <div id="header-container">
      <div class="slackey-regular">SMAT</div>
      <div></div>
    </div>

    <div id="main-container">
      <div id="blockly-container"></div>
      <!-- A <div id="output-column"> foi removida daqui -->
      <div id="code-output-container" style="display: none"> <!-- Mantido para lógica interna do JSON -->
        <h3>JSON Gerado:</h3>
        <pre id="code-output"></pre>
      </div>
    </div>

    <xml id="toolbox" style="display: none">
      <category name="Movements" colour="120">
        <block type="robo_pose"></block>
        <block type="movimento_sequence"></block>
      </category>
    </xml>

    <script>
      window.addEventListener("load", function () {
        // Inicializar o Blockly
        var blocklyDiv = document.getElementById("blockly-container");
        var workspace = Blockly.inject(blocklyDiv, {
          toolbox: document.getElementById("toolbox"),
          grid: {
            spacing: 20,
            length: 3,
            colour: "#ccc",
            snap: true,
          },
          zoom: {
            controls: true,
            wheel: true,
            startScale: 1.0,
            maxScale: 3,
            minScale: 0.3,
            scaleSpeed: 1.2,
          },
          trashcan: true,
        });

        // Função para redimensionar o Blockly (simplificada)
        setTimeout(() => {
          Blockly.svgResize(workspace);
        }, 0);

        // Atualizar o JSON gerado quando o workspace mudar
        function updateGeneratedJson() {
          var code = Blockly.JavaScript.workspaceToCode(workspace);
          console.log("Raw output from workspaceToCode:", code);

          if (code && code.trim() !== "") {
            let jsonObjects = code.trim();
            if (jsonObjects.endsWith(";")) {
              jsonObjects = jsonObjects.slice(0, -1).trim();
            }
            if (jsonObjects === "") {
              document.getElementById("code-output").textContent = "[]";
              return;
            }
            try {
              JSON.parse(jsonObjects);
              document.getElementById("code-output").textContent = jsonObjects;
            } catch (e) {
              const individualJsons = jsonObjects.replace(/}\s*{/g, "},\n{");
              const potentialArray = "[" + individualJsons + "]";
              try {
                JSON.parse(potentialArray);
                document.getElementById("code-output").textContent =
                  potentialArray;
              } catch (eArrayParse) {
                document.getElementById("code-output").textContent =
                  jsonObjects;
                console.error(
                  "Falha ao formatar o código gerado como um array JSON. Código original:",
                  jsonObjects,
                  "Erro de parse do array:",
                  eArrayParse
                );
              }
            }
          } else {
            document.getElementById("code-output").textContent = "[]";
          }
        }
        workspace.addChangeListener(updateGeneratedJson);

        // Enviar para o Robô (Executar) - Modificado para usar endpoints Flask
        document
          .getElementById("execute-btn")
          .addEventListener("click", function () {
            var jsonOutput = document.getElementById("code-output").textContent;
            console.log("Botão Executar pressionado. JSON para enviar:", jsonOutput);

            let dataToSend;
            try {
              dataToSend = JSON.parse(jsonOutput);
            } catch (error) {
              alert("Erro de parsing no JSON gerado: " + error + '\nVerifique a área "JSON Gerado" (oculta).');
              console.error("Erro de parsing no JSON:", error);
              return;
            }

            // Enviar dados via fetch para endpoint Flask
            fetch("/execute", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({ robot_data: dataToSend }),
            })
              .then((response) => response.json())
              .then((data) => {
                if (data.success) {
                  console.log("Dados enviados com sucesso para o painel de controle.");
                } else {
                  console.error("Falha ao enviar dados:", data.error);
                  alert("Falha ao enviar dados: " + (data.error || "Erro desconhecido"));
                }
              })
              .catch((error) => {
                console.error("Erro ao comunicar com o servidor:", error);
                alert("Erro ao comunicar com o servidor: " + error);
              });
          });

        // Função de fallback para enviar dados via fetch (comportamento original)
        // Considere remover se não for mais necessária.
        function executeFetchFallback(dataToSend, outputDivElement) { // outputDivElement pode ser null agora
          console.log("Executando fallback com fetch (se aplicável)...");
          // ... (código original do fetch, mas o outputDiv não deve ser usado se removido)
          // Se mantiver, certifique-se de que outputDivElement é verificado.
        }

        // Limpar o workspace
        document
          .getElementById("clear-btn")
          .addEventListener("click", function () {
            if (confirm("Tem certeza que deseja limpar todos os blocos?")) {
              workspace.clear();
              // document.getElementById("program-output").textContent = ""; // Elemento removido
              document.getElementById("code-output").textContent = "[]"; // Limpa JSON para '[]'
            }
          });

        // Salvar blocos
        document
          .getElementById("save-btn")
          .addEventListener("click", function () {
            console.log(
              "Botão 'Salvar Blocos' clicado. Verificando Blockly.Xml..."
            );
            console.log("typeof Blockly:", typeof Blockly);
            if (typeof Blockly !== "undefined") {
              console.log("typeof Blockly.Xml:", typeof Blockly.Xml);
              if (typeof Blockly.Xml !== "undefined") {
                console.log(
                  "typeof Blockly.Xml.workspaceToDom:",
                  typeof Blockly.Xml.workspaceToDom
                );
              }
              console.log("typeof Blockly.utils:", typeof Blockly.utils);
              if (typeof Blockly.utils !== "undefined") {
                console.log(
                  "typeof Blockly.utils.xml:",
                  typeof Blockly.utils.xml
                );
                if (typeof Blockly.utils.xml !== "undefined") {
                  console.log(
                    "typeof Blockly.utils.xml.domToText:",
                    typeof Blockly.utils.xml.domToText
                  );
                }
              }
            }

            if (
              typeof Blockly === "undefined" ||
              typeof Blockly.Xml === "undefined" ||
              typeof Blockly.utils === "undefined" ||
              typeof Blockly.utils.xml === "undefined" ||
              typeof Blockly.Xml.workspaceToDom !== "function" ||
              typeof Blockly.utils.xml.domToText !== "function"
            ) {
              alert(
                "Erro: Funções essenciais do Blockly para salvar XML não estão disponíveis."
              );
              console.error(
                "Erro: Funções essenciais do Blockly para salvar XML não estão disponíveis. Blockly:",
                Blockly,
                "Blockly.Xml:",
                Blockly && Blockly.Xml,
                "Blockly.utils.xml:",
                Blockly && Blockly.utils && Blockly.utils.xml
              );
              return;
            }
            try {
              var xml = Blockly.Xml.workspaceToDom(workspace);
              var xmlText = Blockly.utils.xml.domToText(xml);

              fetch("/save", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify({ blocks: xmlText }),
              })
                .then((response) => response.json())
                .then((data) => {
                  if (data.success) {
                    alert("Blocos salvos com sucesso!");
                  } else {
                    alert(
                      "Erro ao salvar blocos: " +
                        (data.error || "Erro desconhecido")
                    );
                  }
                })
                .catch((error) => {
                  alert("Erro na comunicação ao salvar: " + error);
                });
            } catch (e) {
              alert("Erro ao serializar os blocos: " + e);
              console.error("Erro ao serializar blocos (save-btn):", e);
            }
          });

        // Carregar blocos
        document
          .getElementById("load-btn")
          .addEventListener("click", function () {
            console.log(
              "Botão 'Carregar Blocos' clicado. Verificando Blockly.Xml..."
            );
            console.log("typeof Blockly:", typeof Blockly);
            if (typeof Blockly !== "undefined") {
              console.log("typeof Blockly.Xml:", typeof Blockly.Xml);
              if (typeof Blockly.Xml !== "undefined") {
                console.log(
                  "typeof Blockly.Xml.domToWorkspace:",
                  typeof Blockly.Xml.domToWorkspace
                );
              }
              console.log("typeof Blockly.utils:", typeof Blockly.utils);
              if (typeof Blockly.utils !== "undefined") {
                console.log(
                  "typeof Blockly.utils.xml:",
                  typeof Blockly.utils.xml
                );
                if (typeof Blockly.utils.xml !== "undefined") {
                  console.log(
                    "typeof Blockly.utils.xml.textToDom:",
                    typeof Blockly.utils.xml.textToDom
                  );
                }
              }
            }

            fetch("/load")
              .then((response) => response.json())
              .then((data) => {
                if (data.success && data.blocks) {
                  if (
                    typeof Blockly === "undefined" ||
                    typeof Blockly.Xml === "undefined" ||
                    typeof Blockly.utils === "undefined" ||
                    typeof Blockly.utils.xml === "undefined" ||
                    typeof Blockly.utils.xml.textToDom !== "function" ||
                    typeof Blockly.Xml.domToWorkspace !== "function"
                  ) {
                    let errorMsg =
                      "Erro: Funções essenciais do Blockly para carregar XML não estão disponíveis.";
                    console.error(
                      errorMsg,
                      "Blockly:",
                      Blockly,
                      "Blockly.Xml:",
                      Blockly && Blockly.Xml,
                      "Blockly.utils.xml:",
                      Blockly && Blockly.utils && Blockly.utils.xml
                    );
                    alert(errorMsg);
                    return;
                  }
                  try {
                    workspace.clear();
                    var xml = Blockly.utils.xml.textToDom(data.blocks);
                    Blockly.Xml.domToWorkspace(xml, workspace);
                    alert("Blocos carregados com sucesso!");
                    updateGeneratedJson();
                  } catch (e) {
                    alert("Erro ao carregar blocos para o workspace: " + e);
                    console.error(
                      "Erro detalhado ao carregar blocos para o workspace (load-btn):",
                      e
                    );
                    workspace.clear();
                  }
                } else {
                  alert(
                    data.error ||
                      "Nenhum bloco salvo encontrado ou falha ao carregar."
                  );
                }
              })
              .catch((error) => {
                alert("Erro na comunicação ao carregar: " + error);
                console.error("Erro de fetch ao carregar blocos:", error);
              });
          });

        // Adicionar blocos padrão ao carregar
        var defaultBlocksXml = `
      <xml xmlns="https://developers.google.com/blockly/xml">
        <block type="movimento_sequence" id="default_movimento" x="50" y="50">
          <field name="FPS">12</field>
          <field name="Duracao">150</field>
          <value name="Inicio">
            <block type="robo_pose" id="default_inicio">
              <field name="X">0</field>
              <field name="Y">0</field>
              <field name="BDireito">0</field>
              <field name="BEsquerdo">0</field>
              <field name="PDireito">0</field>
              <field name="PEsquerdo">0</field>
            </block>
          </value>
          <value name="Fim">
            <block type="robo_pose" id="default_fim">
              <field name="X">0</field>
              <field name="Y">0</field>
              <field name="BDireito">0</field>
              <field name="BEsquerdo">0</field>
              <field name="PDireito">0</field>
              <field name="PEsquerdo">0</field>
            </block>
          </value>
        </block>
      </xml>
      `;
        console.log(
          "Verificando Blockly e Blockly.Xml antes de carregar blocos padrão (dentro do window.onload):"
        );
        console.log("Blockly:", typeof Blockly);
        if (typeof Blockly !== "undefined") {
          console.log("Blockly.Xml:", typeof Blockly.Xml);
          if (typeof Blockly.Xml !== "undefined") {
            console.log(
              "Blockly.Xml.domToWorkspace:",
              typeof Blockly.Xml.domToWorkspace
            );
          }
          console.log("Blockly.utils:", typeof Blockly.utils);
          if (typeof Blockly.utils !== "undefined") {
            console.log("Blockly.utils.xml:", typeof Blockly.utils.xml);
            if (typeof Blockly.utils.xml !== "undefined") {
              console.log(
                "Blockly.utils.xml.textToDom:",
                typeof Blockly.utils.xml.textToDom
              );
            }
          }
        }

        try {
          if (
            typeof Blockly !== "undefined" &&
            typeof Blockly.Xml !== "undefined" &&
            typeof Blockly.utils !== "undefined" &&
            typeof Blockly.utils.xml !== "undefined" &&
            typeof Blockly.utils.xml.textToDom === "function" &&
            typeof Blockly.Xml.domToWorkspace === "function"
          ) {
            var xml = Blockly.utils.xml.textToDom(defaultBlocksXml);
            Blockly.Xml.domToWorkspace(xml, workspace);
          } else {
            console.error(
              "Funções XML do Blockly (textToDom ou domToWorkspace) não estão disponíveis. Não foi possível carregar blocos padrão."
            );
            alert(
              "Alerta: Não foi possível carregar os blocos padrão iniciais devido à falta de funções XML do Blockly."
            );
          }
        } catch (e) {
          console.error(
            "Erro ao carregar blocos padrão (dentro do try-catch principal):",
            e
          );
          alert(
            "Alerta: Erro ao tentar carregar os blocos padrão iniciais: " +
              e.message
          );
        }

        updateGeneratedJson(); // Atualiza o JSON ao carregar a página e após adicionar blocos padrão
      }); // Fim do window.addEventListener('load', ...)
    </script>
    <div id="button-container">
      <div>
        <button id="save-btn">Save blocks</button>
        <button id="load-btn">Load Blocks</button>
        <button id="clear-btn">Clean Blocks</button>
      </div>
      <div>
        <button id="execute-btn">Send to the robot</button>
        <button>Add Background</button>
        <button>Add Soundtrack</button>
      </div>
    </div>
  </body>
</html>
