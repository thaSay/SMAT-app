<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Programação em Blocos para Robô Stop Motion</title>
  <script src="https://unpkg.com/blockly/blockly.min.js"></script>
  <!-- Certifique-se que o gerador JavaScript do Blockly está incluído se não for o padrão -->
  <script src="https://unpkg.com/blockly/javascript_compressed.js"></script>
  <script src="https://unpkg.com/blockly/msg/pt-br.js"></script>
  <!-- Scripts locais para blocos e geradores -->
  <script src="{{ url_for('static', filename='blocks.js') }}"></script>
  <script src="{{ url_for('static', filename='generator.js') }}"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      display: flex;
      height: 100vh;
      flex-direction: column;
    }
    #header {
      background-color: #4a6ea9;
      color: white;
      padding: 10px;
      text-align: center;
    }
    #main-container {
      display: flex;
      flex: 1;
      overflow: hidden; /* Para evitar barras de rolagem desnecessárias no corpo */
    }
    #blockly-container {
      flex: 2;
      height: 100%;
      position: relative; /* Necessário para o Blockly se dimensionar corretamente */
    }
    #output-column {
      flex: 1;
      background-color: #f0f0f0;
      padding: 10px;
      display: flex;
      flex-direction: column;
      overflow-y: auto; /* Barra de rolagem se o conteúdo exceder */
    }
    #code-output-container, #program-output-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      margin-bottom: 10px;
      min-height: 150px; /* Altura mínima para as caixas de saída */
    }
    #code-output, #program-output {
      flex: 1;
      background-color: white;
      border: 1px solid #ddd;
      padding: 10px;
      font-family: monospace;
      overflow: auto;
      white-space: pre-wrap; /* Para quebrar linha no JSON */
      word-break: break-all; /* Para quebrar palavras longas */
    }
    #button-container {
      display: flex;
      justify-content: space-between;
      padding: 10px;
      background-color: #e0e0e0;
    }
    button {
      padding: 8px 16px;
      background-color: #4a6ea9;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover {
      background-color: #3a5ea9;
    }
    #execute-btn {
      background-color: #4caf50;
    }
    #execute-btn:hover {
      background-color: #3a9140;
    }
    #clear-btn {
      background-color: #f44336;
    }
    #clear-btn:hover {
      background-color: #d32f2f;
    }
    h3 {
      margin-top: 0;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <div id="header">
    <h1>Programação em Blocos para Robô Stop Motion</h1>
  </div>
  
  <div id="button-container">
    <div>
      <button id="save-btn">Salvar Blocos</button>
      <button id="load-btn">Carregar Blocos</button>
    </div>
    <div>
      <button id="clear-btn">Limpar Blocos</button>
      <button id="execute-btn">Enviar para Robô</button>
    </div>
  </div>
  
  <div id="main-container">
    <div id="blockly-container"></div>
    <div id="output-column">
      <div id="code-output-container">
        <h3>JSON Gerado:</h3>
        <pre id="code-output"></pre>
      </div>
      <div id="program-output-container">
        <h3>Resposta do Servidor:</h3>
        <pre id="program-output"></pre>
      </div>
    </div>
  </div>

  <xml id="toolbox" style="display: none">
    <category name="Movimentos" colour="120">
      <block type="robo_pose"></block>
      <block type="movimento_sequence"></block>
    </category>
  </xml>

  <script>
    // Inicializar o Blockly
    var blocklyDiv = document.getElementById('blockly-container');
    var workspace = Blockly.inject(blocklyDiv, {
      toolbox: document.getElementById('toolbox'),
      grid: {
        spacing: 20,
        length: 3,
        colour: '#ccc',
        snap: true
      },
      zoom: {
        controls: true,
        wheel: true,
        startScale: 1.0,
        maxScale: 3,
        minScale: 0.3,
        scaleSpeed: 1.2
      },
      trashcan: true
    });

    // Função para redimensionar o Blockly quando a janela muda de tamanho
    function onResize() {
      var element = blocklyDiv;
      var x = 0;
      var y = 0;
      do {
        x += element.offsetLeft;
        y += element.offsetTop;
        element = element.offsetParent;
      } while (element);
      // Position blocklyDiv over blocklyArea.
      blocklyDiv.style.left = x + 'px';
      blocklyDiv.style.top = y + 'px';
      blocklyDiv.style.width = blocklyDiv.offsetWidth + 'px';
      blocklyDiv.style.height = blocklyDiv.offsetHeight + 'px';
      Blockly.svgResize(workspace);
    };
    // window.addEventListener('resize', onResize, false);
    // onResize(); // Chame uma vez para definir o tamanho inicial
    // A maneira mais simples de garantir o redimensionamento é chamar o resize no final do script
    // ou após o carregamento completo da página.

    // Atualizar o JSON gerado quando o workspace mudar
    function updateGeneratedJson() {
      // Usar Blockly.JavaScript conforme definido em generator.js
      var code = Blockly.JavaScript.workspaceToCode(workspace);
      // Se houver múltiplos blocos de movimento, eles serão concatenados.
      // Precisamos envolvê-los em uma lista JSON.
      if (code) {
        // Adiciona vírgulas entre os objetos JSON e os envolve em colchetes
        // Remove o último ; e \n se houver
        let jsonObjects = code.trim();
        if (jsonObjects.endsWith(';')) {
            jsonObjects = jsonObjects.slice(0, -1).trim();
        }
        // Tenta fazer o parse para ver se é um único objeto ou múltiplos concatenados
        try {
            JSON.parse(jsonObjects); // É um único objeto JSON válido
             document.getElementById('code-output').textContent = jsonObjects;
        } catch (e) {
            // Provavelmente múltiplos objetos, vamos formatar como uma lista
            // Esta heurística assume que cada bloco principal gera um objeto JSON completo.
            // E que eles são separados por nada ou apenas espaços/novas linhas após a remoção do ;
            const individualJsons = jsonObjects.replace(/}\\s*{/g, '}\\\n,{\\\n{'); // Adiciona vírgula entre objetos
            document.getElementById('code-output').textContent = '[' + individualJsons + ']';
        }

      } else {
        document.getElementById('code-output').textContent = '';
      }
    }
    workspace.addChangeListener(updateGeneratedJson);

    // Enviar para o Robô (Executar)
    document.getElementById('execute-btn').addEventListener('click', function() {
      var jsonOutput = document.getElementById('code-output').textContent;
      var outputDiv = document.getElementById('program-output');
      outputDiv.textContent = 'Enviando para o servidor...\n';
      
      let dataToSend;
      try {
        dataToSend = JSON.parse(jsonOutput);
      } catch (error) {
        outputDiv.textContent = 'Erro de parsing no JSON gerado: ' + error + '\nVerifique a área "JSON Gerado".';
        return;
      }

      fetch('/execute', { // A rota definida no app.py
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(dataToSend), // Envia o JSON parseado e re-stringificado
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          outputDiv.textContent = 'Sucesso:\n' + data.message + '\n';
          if (data.processed_output) {
            outputDiv.textContent += 'Saída do Processamento:\n' + data.processed_output.join('\n');
          }
          if (data.received_data) {
             outputDiv.textContent += '\n\nDados Recebidos pelo Servidor:\n' + JSON.stringify(data.received_data, null, 2);
          }
        } else {
          outputDiv.textContent = 'Erro do Servidor: ' + data.error;
           if (data.received_data) {
             outputDiv.textContent += '\n\nDados Enviados:\n' + JSON.stringify(data.received_data, null, 2);
          }
        }
      })
      .catch(error => {
        outputDiv.textContent = 'Erro na comunicação com o servidor: ' + error;
      });
    });

    // Limpar o workspace
    document.getElementById('clear-btn').addEventListener('click', function() {
      if (confirm('Tem certeza que deseja limpar todos os blocos?')) {
        workspace.clear();
        document.getElementById('program-output').textContent = '';
        document.getElementById('code-output').textContent = ''; // Limpa também o JSON gerado
      }
    });

    // Salvar blocos
    document.getElementById('save-btn').addEventListener('click', function() {
      try {
        var xml = Blockly.Xml.workspaceToDom(workspace);
        var xmlText = Blockly.Xml.domToText(xml);
        
        fetch('/save', { // A rota definida no app.py
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({blocks: xmlText}),
        })
        .then(response => response.json())
        .then(data => {
          if (data.success) {
            alert('Blocos salvos com sucesso!');
          } else {
            alert('Erro ao salvar blocos: ' + (data.error || 'Erro desconhecido'));
          }
        })
        .catch(error => {
          alert('Erro na comunicação ao salvar: ' + error);
        });
      } catch (e) {
        alert('Erro ao serializar os blocos: ' + e);
      }
    });

    // Carregar blocos
    document.getElementById('load-btn').addEventListener('click', function() {
      fetch('/load') // A rota definida no app.py
      .then(response => response.json())
      .then(data => {
        if (data.success && data.blocks) {
          try {
            workspace.clear();
            var xml = Blockly.Xml.textToDom(data.blocks);
            Blockly.Xml.domToWorkspace(xml, workspace);
            alert('Blocos carregados com sucesso!');
            updateGeneratedJson(); // Atualiza o JSON após carregar
          } catch (e) {
            alert('Erro ao carregar blocos para o workspace: ' + e);
            workspace.clear(); // Limpa em caso de erro no carregamento
          }
        } else {
          alert(data.error || 'Nenhum bloco salvo encontrado ou falha ao carregar.');
        }
      })
      .catch(error => {
        alert('Erro na comunicação ao carregar: ' + error);
      });
    });
    
    // Chamar o resize do Blockly após tudo estar carregado e o DOM pronto
    window.addEventListener('load', function() {
        // Simples redimensionamento baseado no contêiner
        var blocklyArea = document.getElementById('main-container'); // Ou o contêiner mais direto do blocklyDiv
        var blocklyDiv = document.getElementById('blockly-container');
        function doResize() {
            // Position blocklyDiv over blocklyArea.
            var element = blocklyDiv;
            var x = 0;
            var y = 0;
            // Não precisamos calcular a posição absoluta se o blocklyDiv já está posicionado corretamente por CSS
            
            blocklyDiv.style.width = blocklyArea.offsetWidth * 0.66 + 'px'; // Ex: 2/3 da largura
            blocklyDiv.style.height = blocklyArea.offsetHeight + 'px';
            Blockly.svgResize(workspace);
        }
        // window.addEventListener('resize', doResize, false);
        // doResize(); // Chamada inicial
        // Uma forma mais robusta de garantir que o Blockly se redimensione corretamente
        // é usar um pequeno timeout ou garantir que o contêiner tenha dimensões definidas.
        setTimeout(() => {
            Blockly.svgResize(workspace);
        }, 0);

        // Adicionar blocos padrão ao carregar
        var defaultBlocksXml = `
        <xml xmlns="https://developers.google.com/blockly/xml">
          <block type="movimento_sequence" id="default_movimento" x="50" y="50">
            <field name="FPS">12</field>
            <field name="Duracao">150</field>
            <value name="Inicio">
              <block type="robo_pose" id="default_inicio">
                <field name="X">0</field>
                <field name="Y">0</field>
                <field name="BDireito">0</field>
                <field name="BEsquerdo">0</field>
                <field name="PDireito">0</field>
                <field name="PEsquerdo">0</field>
              </block>
            </value>
            <value name="Fim">
              <block type="robo_pose" id="default_fim">
                <field name="X">0</field>
                <field name="Y">0</field>
                <field name="BDireito">0</field>
                <field name="BEsquerdo">0</field>
                <field name="PDireito">0</field>
                <field name="PEsquerdo">0</field>
              </block>
            </value>
          </block>
        </xml>
        `;
        console.log("Verificando Blockly e Blockly.Xml antes de carregar blocos padrão:");
        console.log("Blockly:", typeof Blockly);
        if (typeof Blockly !== 'undefined') {
            console.log("Blockly.Xml:", typeof Blockly.Xml);
            if (typeof Blockly.Xml !== 'undefined') {
                console.log("Blockly.Xml.textToDom:", typeof Blockly.Xml.textToDom);
            }
        }

        try {
            if (typeof Blockly !== 'undefined' && typeof Blockly.Xml !== 'undefined' && typeof Blockly.Xml.textToDom === 'function') {
                var xml = Blockly.Xml.textToDom(defaultBlocksXml);
                Blockly.Xml.domToWorkspace(xml, workspace);
            } else {
                console.error("Blockly.Xml.textToDom não está disponível. Não foi possível carregar blocos padrão.");
                // Opcional: Tentar carregar após um pequeno delay, caso seja um problema de tempo de carregamento
                // setTimeout(function() {
                //     try {
                //         if (Blockly && Blockly.Xml && Blockly.Xml.textToDom) {
                //             var xml = Blockly.Xml.textToDom(defaultBlocksXml);
                //             Blockly.Xml.domToWorkspace(xml, workspace);
                //             updateGeneratedJson();
                //         } else {
                //             console.error("Blockly.Xml.textToDom ainda não disponível após delay.");
                //         }
                //     } catch (e_delay) {
                //         console.error("Erro ao carregar blocos padrão (após delay):", e_delay);
                //     }
                // }, 1000); // Tenta após 1 segundo
            }
        } catch (e) {
            console.error("Erro ao carregar blocos padrão (dentro do try-catch principal):", e);
        }

        updateGeneratedJson(); // Atualiza o JSON ao carregar a página e após adicionar blocos padrão
    });
  </script>
</body>
</html>
